// Hemlock Functions Demo
// Showcases first-class functions, closures, and recursion

print("=== Hemlock Functions Demo ===");
print("");

// 1. Basic named function
print("1. Basic function:");
fn add(a, b) {
    return a + b;
}
print(add(5, 3));
print("");

// 2. Function with type annotations
print("2. Typed function:");
fn multiply(x: i32, y: i32): i32 {
    return x * y;
}
print(multiply(7, 6));
print("");

// 3. Recursive function - factorial
print("3. Recursion (factorial):");
fn factorial(n: i32): i32 {
    if (n <= 1) {
        return 1;
    }
    return n * factorial(n - 1);
}
print(factorial(6));
print("");

// 4. Closures - function that returns a function
print("4. Closures:");
fn makeMultiplier(factor) {
    return fn(x) {
        return x * factor;
    };
}
let double = makeMultiplier(2);
let triple = makeMultiplier(3);
print(double(5));
print(triple(5));
print("");

// 5. Anonymous functions as first-class values
print("5. Anonymous functions:");
let square = fn(n) {
    return n * n;
};
print(square(8));
print("");

// 6. Higher-order functions - passing functions as arguments
print("6. Higher-order functions:");
fn apply(func, value) {
    return func(value);
}
print(apply(square, 9));
print("");

// 7. Lexical scoping
print("7. Lexical scoping:");
let message = 100;
fn getMessage() {
    return message + 23;
}
print(getMessage());
print("");

// 8. Counter closure (stateful closure)
print("8. Counter closure:");
fn makeCounter() {
    let count = 0;
    return fn() {
        count = count + 1;
        return count;
    };
}
let counter = makeCounter();
print(counter());
print(counter());
print(counter());
print("");

// 9. Fibonacci with recursion
print("9. Fibonacci sequence:");
fn fib(n) {
    if (n <= 1) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}
let i = 0;
while (i < 10) {
    print(fib(i));
    i = i + 1;
}

print("");
print("=== Demo Complete ===");
