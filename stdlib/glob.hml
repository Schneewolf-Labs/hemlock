// @stdlib/glob - Glob pattern matching and file finding
//
// Provides functions for matching file paths against glob patterns
// and finding files in the filesystem.
//
// Usage:
//   import { glob, match } from "@stdlib/glob";
//   let files = glob("src/**/*.hml");
//   print(match("file.txt", "*.txt"));  // true

import { list_dir, is_dir, is_file, exists, cwd } from "@stdlib/fs";
import { join, basename, dirname, SEP } from "@stdlib/path";

// ============================================================================
// Pattern Matching
// ============================================================================

// Match a string against a glob pattern
// Parameters:
//   pattern: string - Glob pattern (supports *, ?, [abc], [!abc])
//   text: string - String to match
// Returns: bool - True if text matches pattern
export fn match(pattern, text): bool {
    if (typeof(pattern) != "string" || typeof(text) != "string") {
        throw "match() requires string arguments";
    }

    return match_pattern(pattern, text, 0, 0);
}

// Recursive pattern matching
fn match_pattern(pattern, text, pi, ti): bool {
    while (pi < pattern.length) {
        let p_char = pattern.char_at(pi);

        if (p_char == '*') {
            // * matches zero or more characters (not including /)
            // Try matching zero characters first, then one, then two, etc.
            pi = pi + 1;

            // Handle consecutive *s
            while (pi < pattern.length && pattern.char_at(pi) == '*') {
                pi = pi + 1;
            }

            // If pattern ends with *, match rest of text (except /)
            if (pi >= pattern.length) {
                // Check no / in remaining text
                let j = ti;
                while (j < text.length) {
                    if (text.char_at(j) == '/') {
                        return false;
                    }
                    j = j + 1;
                }
                return true;
            }

            // Try matching with different amounts consumed by *
            while (ti <= text.length) {
                if (match_pattern(pattern, text, pi, ti)) {
                    return true;
                }
                if (ti < text.length && text.char_at(ti) == '/') {
                    // * doesn't match /
                    break;
                }
                ti = ti + 1;
            }
            return false;

        } else if (p_char == '?') {
            // ? matches exactly one character (not /)
            if (ti >= text.length) {
                return false;
            }
            if (text.char_at(ti) == '/') {
                return false;
            }
            pi = pi + 1;
            ti = ti + 1;

        } else if (p_char == '[') {
            // Character class
            if (ti >= text.length) {
                return false;
            }

            let t_char = text.char_at(ti);
            let negate = false;
            pi = pi + 1;

            if (pi < pattern.length && pattern.char_at(pi) == '!') {
                negate = true;
                pi = pi + 1;
            }

            let matched = false;
            let prev_char = null;

            while (pi < pattern.length && pattern.char_at(pi) != ']') {
                let c = pattern.char_at(pi);

                // Check for range
                if (c == '-' && prev_char != null && pi + 1 < pattern.length && pattern.char_at(pi + 1) != ']') {
                    pi = pi + 1;
                    let end_char = pattern.char_at(pi);
                    let prev_code: i32 = prev_char;
                    let end_code: i32 = end_char;
                    let t_code: i32 = t_char;

                    if (t_code >= prev_code && t_code <= end_code) {
                        matched = true;
                    }
                } else {
                    if (c == t_char) {
                        matched = true;
                    }
                    prev_char = c;
                }

                pi = pi + 1;
            }

            // Skip closing ]
            if (pi < pattern.length) {
                pi = pi + 1;
            }

            if (negate) {
                matched = !matched;
            }

            if (!matched) {
                return false;
            }

            ti = ti + 1;

        } else {
            // Regular character - must match exactly
            if (ti >= text.length) {
                return false;
            }
            if (text.char_at(ti) != p_char) {
                return false;
            }
            pi = pi + 1;
            ti = ti + 1;
        }
    }

    // Pattern exhausted - text must also be exhausted
    return ti >= text.length;
}

// ============================================================================
// Globstar Matching (** support)
// ============================================================================

// Match a path against a glob pattern with ** support
// Parameters:
//   pattern: string - Glob pattern (supports *, ?, **, [abc], [!abc])
//   path: string - Path to match
// Returns: bool - True if path matches pattern
export fn match_path(pattern, path): bool {
    if (typeof(pattern) != "string" || typeof(path) != "string") {
        throw "match_path() requires string arguments";
    }

    // Split into segments
    let pattern_parts = pattern.split("/");
    let path_parts = path.split("/");

    return match_parts(pattern_parts, path_parts, 0, 0);
}

// Match path segments recursively
fn match_parts(pattern_parts, path_parts, pi, ti): bool {
    while (pi < pattern_parts.length) {
        let p_part = pattern_parts[pi];

        if (p_part == "**") {
            // ** matches zero or more directories
            pi = pi + 1;

            // Handle trailing **
            if (pi >= pattern_parts.length) {
                return true;  // ** at end matches anything
            }

            // Try matching with different amounts consumed by **
            while (ti <= path_parts.length) {
                if (match_parts(pattern_parts, path_parts, pi, ti)) {
                    return true;
                }
                ti = ti + 1;
            }
            return false;

        } else {
            // Regular segment - must match
            if (ti >= path_parts.length) {
                return false;
            }

            if (!match(p_part, path_parts[ti])) {
                return false;
            }

            pi = pi + 1;
            ti = ti + 1;
        }
    }

    // Pattern exhausted - path must also be exhausted
    return ti >= path_parts.length;
}

// ============================================================================
// File Finding
// ============================================================================

// Find files matching a glob pattern
// Parameters:
//   pattern: string - Glob pattern (supports *, ?, **, [abc])
//   base_dir: string - Base directory (optional, defaults to ".")
// Returns: array<string> - Matching file paths
export fn glob(pattern, base_dir?: "."): array {
    if (typeof(pattern) != "string") {
        throw "glob() requires string pattern";
    }

    let results: array = [];

    // Handle absolute patterns
    let is_absolute = pattern.starts_with("/");
    let search_dir = base_dir;
    let search_pattern = pattern;

    if (is_absolute) {
        search_dir = "/";
        search_pattern = pattern.slice(1, pattern.length);
    }

    // Start recursive search
    glob_recurse(search_dir, search_pattern, "", results);

    return results;
}

// Recursive glob helper
fn glob_recurse(dir, pattern, prefix, results) {
    // Try to list directory contents
    let entries: array = [];
    try {
        entries = list_dir(dir);
    } catch (e) {
        // Directory not accessible, skip
        return;
    }

    // Check if pattern has ** at the start
    let has_globstar = pattern.starts_with("**/");

    // Get first segment of pattern
    let slash_idx = pattern.find("/");
    let first_part = "";
    let rest_pattern = "";

    if (slash_idx >= 0) {
        first_part = pattern.slice(0, slash_idx);
        rest_pattern = pattern.slice(slash_idx + 1, pattern.length);
    } else {
        first_part = pattern;
        rest_pattern = "";
    }

    // Iterate through directory entries
    let i = 0;
    while (i < entries.length) {
        let entry = entries[i];
        let entry_path = "";
        if (dir == ".") {
            entry_path = entry;
        } else if (dir == "/") {
            entry_path = "/" + entry;
        } else {
            entry_path = dir + "/" + entry;
        }

        let result_path = "";
        if (prefix == "") {
            result_path = entry;
        } else {
            result_path = prefix + "/" + entry;
        }

        if (first_part == "**") {
            // ** - match zero or more directories
            let is_directory = false;
            try {
                is_directory = is_dir(entry_path);
            } catch (e) {
                // Skip inaccessible entries
                i = i + 1;
                continue;
            }

            if (rest_pattern == "") {
                // ** at end - match everything
                results.push(result_path);
                if (is_directory) {
                    glob_recurse(entry_path, "**", result_path, results);
                }
            } else {
                // Try matching rest with current entry
                if (match_path(rest_pattern, entry)) {
                    results.push(result_path);
                }

                // If directory, continue recursing with **
                if (is_directory) {
                    // Try matching with ** continuing
                    glob_recurse(entry_path, pattern, result_path, results);
                    // Also try matching without ** (consume it)
                    glob_recurse(entry_path, rest_pattern, result_path, results);
                }
            }
        } else {
            // Regular pattern segment
            if (match(first_part, entry)) {
                if (rest_pattern == "") {
                    // End of pattern - this is a match
                    results.push(result_path);
                } else {
                    // More pattern to match - must be directory
                    let is_directory = false;
                    try {
                        is_directory = is_dir(entry_path);
                    } catch (e) {
                        // Skip inaccessible entries
                        i = i + 1;
                        continue;
                    }

                    if (is_directory) {
                        glob_recurse(entry_path, rest_pattern, result_path, results);
                    }
                }
            }
        }

        i = i + 1;
    }
}

// ============================================================================
// Utility Functions
// ============================================================================

// Escape special glob characters in a string
// Parameters:
//   text: string - String to escape
// Returns: string - Escaped string safe for literal matching
export fn escape(text): string {
    if (typeof(text) != "string") {
        throw "escape() requires string argument";
    }

    let result = "";
    let i = 0;

    while (i < text.length) {
        let c = text.char_at(i);

        // Escape special characters: * ? [ { }
        // Note: ] is only special inside [...], so we escape [ which prevents the class
        if (c == '*' || c == '?' || c == '[' || c == '{' || c == '}') {
            result = result + "[" + c + "]";
        } else {
            result = result + c;
        }

        i = i + 1;
    }

    return result;
}

// Check if a pattern contains any glob special characters
// Parameters:
//   pattern: string - Pattern to check
// Returns: bool - True if pattern has glob characters
export fn has_magic(pattern): bool {
    if (typeof(pattern) != "string") {
        return false;
    }

    let i = 0;
    while (i < pattern.length) {
        let c = pattern.char_at(i);
        if (c == '*' || c == '?' || c == '[' || c == '{') {
            return true;
        }
        i = i + 1;
    }

    return false;
}

// Filter a list of paths by a glob pattern
// Parameters:
//   paths: array<string> - Paths to filter
//   pattern: string - Glob pattern
// Returns: array<string> - Matching paths
export fn filter(paths, pattern): array {
    if (typeof(paths) != "array" || typeof(pattern) != "string") {
        throw "filter() requires array and string arguments";
    }

    let results: array = [];
    let i = 0;

    while (i < paths.length) {
        let path = paths[i];
        if (typeof(path) == "string") {
            // Use match_path for full path matching with ** support
            if (match_path(pattern, path)) {
                results.push(path);
            }
        }
        i = i + 1;
    }

    return results;
}

// Translate a glob pattern to a regular expression string
// Parameters:
//   pattern: string - Glob pattern
// Returns: string - Regex pattern
export fn translate(pattern): string {
    if (typeof(pattern) != "string") {
        throw "translate() requires string argument";
    }

    let result = "^";
    let i = 0;

    while (i < pattern.length) {
        let c = pattern.char_at(i);

        if (c == '*') {
            // Check for **
            if (i + 1 < pattern.length && pattern.char_at(i + 1) == '*') {
                result = result + ".*";
                i = i + 2;
                continue;
            }
            result = result + "[^/]*";
        } else if (c == '?') {
            result = result + "[^/]";
        } else if (c == '[') {
            // Character class - pass through mostly as-is
            result = result + "[";
            i = i + 1;
            if (i < pattern.length && pattern.char_at(i) == '!') {
                result = result + "^";
                i = i + 1;
            }
            while (i < pattern.length && pattern.char_at(i) != ']') {
                result = result + pattern.char_at(i);
                i = i + 1;
            }
            result = result + "]";
        } else if (c == '.' || c == '(' || c == ')' || c == '+' ||
                   c == '|' || c == '^' || c == '$' || c == '@' ||
                   c == '{' || c == '}' || c == '\\') {
            // Escape regex special characters
            result = result + "\\" + c;
        } else {
            result = result + c;
        }

        i = i + 1;
    }

    result = result + "$";
    return result;
}
