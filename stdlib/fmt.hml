// @stdlib/fmt - String formatting utilities
//
// Provides printf-style string formatting and text manipulation.
//
// Usage:
//   import { format, pad_left, pad_right } from "@stdlib/fmt";
//   let msg = format("Hello, %s! You have %d messages.", ["Alice", 5]);
//   print(msg);  // "Hello, Alice! You have 5 messages."

// ============================================================================
// Format Specifiers
// ============================================================================
//
// %s - String
// %d, %i - Integer (decimal)
// %f - Float (default 6 decimal places)
// %.Nf - Float with N decimal places
// %x, %X - Hexadecimal (lower/upper)
// %o - Octal
// %b - Binary
// %e, %E - Scientific notation (lower/upper e)
// %% - Literal percent sign
// %c - Character (from integer code)
// %q - Quoted string (with escapes)
//
// Width and padding:
// %10s - Right-pad to 10 chars
// %-10s - Left-pad to 10 chars
// %010d - Zero-pad to 10 chars
// ============================================================================

// Format a string with placeholders
// Parameters:
//   template: string - Format string with % placeholders
//   args: array - Arguments to substitute
// Returns: string - Formatted string
export fn format(template, args): string {
    if (typeof(template) != "string") {
        throw "format() requires string template";
    }
    if (typeof(args) != "array") {
        throw "format() requires array of arguments";
    }

    let result = "";
    let arg_idx = 0;
    let i = 0;

    while (i < template.length) {
        let c = template.char_at(i);

        if (c != '%') {
            result = result + c;
            i = i + 1;
            continue;
        }

        // Found %, parse format specifier
        i = i + 1;
        if (i >= template.length) {
            result = result + '%';
            break;
        }

        let next = template.char_at(i);

        // Check for %%
        if (next == '%') {
            result = result + '%';
            i = i + 1;
            continue;
        }

        // Parse flags
        let left_align = false;
        let zero_pad = false;
        let plus_sign = false;
        let space_sign = false;

        while (i < template.length) {
            let flag = template.char_at(i);
            if (flag == '-') {
                left_align = true;
                i = i + 1;
            } else if (flag == '0') {
                zero_pad = true;
                i = i + 1;
            } else if (flag == '+') {
                plus_sign = true;
                i = i + 1;
            } else if (flag == ' ') {
                space_sign = true;
                i = i + 1;
            } else {
                break;
            }
        }

        // Parse width
        let width = 0;
        while (i < template.length) {
            let wc = template.char_at(i);
            let wcode: i32 = wc;
            if (wcode >= 48 && wcode <= 57) {  // 0-9
                width = width * 10 + (wcode - 48);
                i = i + 1;
            } else {
                break;
            }
        }

        // Parse precision
        let precision = -1;
        if (i < template.length && template.char_at(i) == '.') {
            i = i + 1;
            precision = 0;
            while (i < template.length) {
                let pc = template.char_at(i);
                let pcode: i32 = pc;
                if (pcode >= 48 && pcode <= 57) {
                    precision = precision * 10 + (pcode - 48);
                    i = i + 1;
                } else {
                    break;
                }
            }
        }

        // Parse specifier
        if (i >= template.length) {
            result = result + '%';
            break;
        }

        let spec = template.char_at(i);
        i = i + 1;

        // Get argument
        let arg = null;
        if (arg_idx < args.length) {
            arg = args[arg_idx];
            arg_idx = arg_idx + 1;
        }

        // Format argument based on specifier
        let formatted = "";

        if (spec == 's') {
            // String
            if (arg == null) {
                formatted = "null";
            } else {
                formatted = "" + arg;
            }
            if (precision >= 0 && formatted.length > precision) {
                formatted = formatted.slice(0, precision);
            }
        } else if (spec == 'd' || spec == 'i') {
            // Integer
            let num = 0;
            if (arg != null) {
                num = to_int(arg);
            }
            formatted = format_int(num, 10, false, plus_sign, space_sign);
        } else if (spec == 'f') {
            // Float
            let num = 0.0;
            if (arg != null) {
                let num_str: string = "" + arg;
                // Simple conversion - multiply string by 1.0
                num = arg * 1.0;
            }
            if (precision < 0) {
                precision = 6;
            }
            formatted = format_float(num, precision);
        } else if (spec == 'e' || spec == 'E') {
            // Scientific notation
            let num = 0.0;
            if (arg != null) {
                num = arg * 1.0;
            }
            if (precision < 0) {
                precision = 6;
            }
            formatted = format_scientific(num, precision, spec == 'E');
        } else if (spec == 'x' || spec == 'X') {
            // Hexadecimal
            let num = 0;
            if (arg != null) {
                num = to_int(arg);
            }
            formatted = format_int(num, 16, spec == 'X', false, false);
        } else if (spec == 'o') {
            // Octal
            let num = 0;
            if (arg != null) {
                num = to_int(arg);
            }
            formatted = format_int(num, 8, false, false, false);
        } else if (spec == 'b') {
            // Binary
            let num = 0;
            if (arg != null) {
                num = to_int(arg);
            }
            formatted = format_int(num, 2, false, false, false);
        } else if (spec == 'c') {
            // Character
            let code = 0;
            if (arg != null) {
                code = to_int(arg);
            }
            let ch: rune = code;
            formatted = "" + ch;
        } else if (spec == 'q') {
            // Quoted string
            if (arg == null) {
                formatted = "null";
            } else {
                formatted = quote_string("" + arg);
            }
        } else {
            // Unknown specifier - include literally
            formatted = "%" + spec;
            arg_idx = arg_idx - 1;  // Don't consume argument
        }

        // Apply width padding
        if (width > 0 && formatted.length < width) {
            let pad_char = " ";
            if (zero_pad && !left_align) {
                pad_char = "0";
            }
            let padding = "";
            let pad_count = width - formatted.length;
            let j = 0;
            while (j < pad_count) {
                padding = padding + pad_char;
                j = j + 1;
            }
            if (left_align) {
                formatted = formatted + padding;
            } else {
                formatted = padding + formatted;
            }
        }

        result = result + formatted;
    }

    return result;
}

// Alias for format
export fn sprintf(template, args): string {
    return format(template, args);
}

// ============================================================================
// Helper Functions
// ============================================================================

// Convert value to integer
fn to_int(val): i64 {
    let t = typeof(val);
    if (t == "i32" || t == "i64" || t == "i16" || t == "i8" ||
        t == "u32" || t == "u64" || t == "u16" || t == "u8") {
        let result: i64 = val;
        return result;
    }
    if (t == "f32" || t == "f64") {
        let result: i64 = val;
        return result;
    }
    if (t == "bool") {
        if (val) {
            return 1;
        }
        return 0;
    }
    if (t == "string") {
        // Try to parse
        return parse_int(val);
    }
    return 0;
}

// Parse integer from string
fn parse_int(s): i64 {
    let result: i64 = 0;
    let negative = false;
    let i = 0;

    if (s.length > 0 && s.char_at(0) == '-') {
        negative = true;
        i = 1;
    } else if (s.length > 0 && s.char_at(0) == '+') {
        i = 1;
    }

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;
        if (code >= 48 && code <= 57) {
            result = result * 10 + (code - 48);
        } else {
            break;
        }
        i = i + 1;
    }

    if (negative) {
        return -result;
    }
    return result;
}

// Format integer in given base
fn format_int(num, base, upper, plus, space): string {
    let digits = "0123456789abcdef";
    if (upper) {
        digits = "0123456789ABCDEF";
    }

    if (num == 0) {
        if (plus) {
            return "+0";
        }
        if (space) {
            return " 0";
        }
        return "0";
    }

    let negative = num < 0;
    if (negative) {
        num = -num;
    }

    let result = "";
    while (num > 0) {
        let digit = num % base;
        result = digits.substr(digit, 1) + result;
        num = divi(num, base);
    }

    if (negative) {
        result = "-" + result;
    } else if (plus) {
        result = "+" + result;
    } else if (space) {
        result = " " + result;
    }

    return result;
}

// Format float with given precision
fn format_float(num, precision): string {
    let negative = num < 0;
    if (negative) {
        num = -num;
    }

    // Get integer part
    let int_part: i64 = num;
    let frac_part = num - int_part;

    // Build integer part string
    let int_str = "";
    if (int_part == 0) {
        int_str = "0";
    } else {
        while (int_part > 0) {
            let digit = int_part % 10;
            let d_char: rune = 48 + digit;
            int_str = d_char + int_str;
            int_part = divi(int_part, 10);
        }
    }

    // Build fractional part string
    let frac_str = "";
    if (precision > 0) {
        frac_str = ".";
        let i = 0;
        while (i < precision) {
            frac_part = frac_part * 10;
            let digit: i64 = frac_part;
            frac_part = frac_part - digit;
            let d_char: rune = 48 + digit;
            frac_str = frac_str + d_char;
            i = i + 1;
        }
    } else if (precision == 0) {
        // No decimal point
    }

    let result = int_str + frac_str;
    if (negative) {
        result = "-" + result;
    }

    return result;
}

// Format number in scientific notation
fn format_scientific(num, precision, upper): string {
    if (num == 0) {
        let zeros = "";
        let i = 0;
        while (i < precision) {
            zeros = zeros + "0";
            i = i + 1;
        }
        if (precision > 0) {
            zeros = "." + zeros;
        }
        if (upper) {
            return "0" + zeros + "E+00";
        }
        return "0" + zeros + "e+00";
    }

    let negative = num < 0;
    if (negative) {
        num = -num;
    }

    // Find exponent
    let exp = 0;
    let mantissa = num;

    if (mantissa >= 10) {
        while (mantissa >= 10) {
            mantissa = mantissa / 10;
            exp = exp + 1;
        }
    } else if (mantissa < 1 && mantissa > 0) {
        while (mantissa < 1) {
            mantissa = mantissa * 10;
            exp = exp - 1;
        }
    }

    // Format mantissa
    let mantissa_str = format_float(mantissa, precision);

    // Format exponent
    let exp_sign = "+";
    if (exp < 0) {
        exp_sign = "-";
        exp = -exp;
    }
    let exp_str = "";
    if (exp < 10) {
        exp_str = "0" + exp;
    } else {
        exp_str = "" + exp;
    }

    let e_char = "e";
    if (upper) {
        e_char = "E";
    }

    let result = mantissa_str + e_char + exp_sign + exp_str;
    if (negative) {
        result = "-" + result;
    }

    return result;
}

// Quote a string with escape sequences
fn quote_string(s): string {
    let result = "\"";
    let i = 0;

    while (i < s.length) {
        let c = s.char_at(i);
        let code: i32 = c;

        if (c == '"') {
            result = result + "\\\"";
        } else if (c == '\\') {
            result = result + "\\\\";
        } else if (c == '\n') {
            result = result + "\\n";
        } else if (c == '\r') {
            result = result + "\\r";
        } else if (c == '\t') {
            result = result + "\\t";
        } else if (code < 32 || code > 126) {
            // Non-printable: use hex escape
            let hi = (code >> 4) & 0x0F;
            let lo = code & 0x0F;
            let hex = "0123456789abcdef";
            result = result + "\\x" + hex.substr(hi, 1) + hex.substr(lo, 1);
        } else {
            result = result + c;
        }

        i = i + 1;
    }

    result = result + "\"";
    return result;
}

// ============================================================================
// String Padding
// ============================================================================

// Pad string on the left to reach target width
// Parameters:
//   s: string - String to pad
//   width: i32 - Target width
//   char: string - Padding character (default: " ")
// Returns: string - Padded string
export fn pad_left(s, width, char?: " "): string {
    if (typeof(s) != "string") {
        throw "pad_left() requires string argument";
    }

    let str: string = s;
    if (str.length >= width) {
        return str;
    }

    let padding = "";
    let pad_char = char;
    if (pad_char.length == 0) {
        pad_char = " ";
    }
    let first_char = pad_char.substr(0, 1);

    let i = str.length;
    while (i < width) {
        padding = padding + first_char;
        i = i + 1;
    }

    return padding + str;
}

// Pad string on the right to reach target width
// Parameters:
//   s: string - String to pad
//   width: i32 - Target width
//   char: string - Padding character (default: " ")
// Returns: string - Padded string
export fn pad_right(s, width, char?: " "): string {
    if (typeof(s) != "string") {
        throw "pad_right() requires string argument";
    }

    let str: string = s;
    if (str.length >= width) {
        return str;
    }

    let padding = "";
    let pad_char = char;
    if (pad_char.length == 0) {
        pad_char = " ";
    }
    let first_char = pad_char.substr(0, 1);

    let i = str.length;
    while (i < width) {
        padding = padding + first_char;
        i = i + 1;
    }

    return str + padding;
}

// Center string within target width
// Parameters:
//   s: string - String to center
//   width: i32 - Target width
//   char: string - Padding character (default: " ")
// Returns: string - Centered string
export fn center(s, width, char?: " "): string {
    if (typeof(s) != "string") {
        throw "center() requires string argument";
    }

    let str: string = s;
    if (str.length >= width) {
        return str;
    }

    let pad_char = char;
    if (pad_char.length == 0) {
        pad_char = " ";
    }
    let first_char = pad_char.substr(0, 1);

    let total_pad = width - str.length;
    let left_pad = divi(total_pad, 2);
    let right_pad = total_pad - left_pad;

    let left = "";
    let i = 0;
    while (i < left_pad) {
        left = left + first_char;
        i = i + 1;
    }

    let right = "";
    i = 0;
    while (i < right_pad) {
        right = right + first_char;
        i = i + 1;
    }

    return left + str + right;
}

// ============================================================================
// Text Manipulation
// ============================================================================

// Truncate string to maximum length with optional suffix
// Parameters:
//   s: string - String to truncate
//   max_len: i32 - Maximum length
//   suffix: string - Suffix to add if truncated (default: "...")
// Returns: string - Truncated string
export fn truncate(s, max_len, suffix?: "..."): string {
    if (typeof(s) != "string") {
        throw "truncate() requires string argument";
    }

    let str: string = s;
    if (str.length <= max_len) {
        return str;
    }

    let suf: string = suffix;
    let cut_len = max_len - suf.length;
    if (cut_len < 0) {
        cut_len = 0;
    }

    return str.slice(0, cut_len) + suf;
}

// Wrap text to specified width
// Parameters:
//   text: string - Text to wrap
//   width: i32 - Maximum line width
// Returns: string - Wrapped text with newlines
export fn wrap(text, width): string {
    if (typeof(text) != "string") {
        throw "wrap() requires string argument";
    }

    if (width <= 0) {
        return text;
    }

    let result = "";
    let words = text.split(" ");
    let current_line = "";

    let i = 0;
    while (i < words.length) {
        let word = words[i];

        if (current_line == "") {
            current_line = word;
        } else if (current_line.length + 1 + word.length <= width) {
            current_line = current_line + " " + word;
        } else {
            if (result != "") {
                result = result + "\n";
            }
            result = result + current_line;
            current_line = word;
        }

        i = i + 1;
    }

    if (current_line != "") {
        if (result != "") {
            result = result + "\n";
        }
        result = result + current_line;
    }

    return result;
}

// ============================================================================
// Number Formatting
// ============================================================================

// Format number with thousands separator
// Parameters:
//   num: number - Number to format
//   sep: string - Separator (default: ",")
// Returns: string - Formatted number
export fn thousands(num, sep?: ","): string {
    let int_val: i64 = num;
    let negative = int_val < 0;
    if (negative) {
        int_val = -int_val;
    }

    let str = "" + int_val;
    let result = "";
    let count = 0;

    let i = str.length - 1;
    while (i >= 0) {
        if (count > 0 && count % 3 == 0) {
            result = sep + result;
        }
        result = str.char_at(i) + result;
        count = count + 1;
        i = i - 1;
    }

    if (negative) {
        result = "-" + result;
    }

    return result;
}

// Format bytes as human-readable size
// Parameters:
//   bytes: i64 - Number of bytes
//   precision: i32 - Decimal places (default: 1)
// Returns: string - Formatted size (e.g., "1.5 MB")
export fn bytes_size(bytes, precision?: 1): string {
    let units = ["B", "KB", "MB", "GB", "TB", "PB"];
    let size: f64 = bytes;
    let unit_idx = 0;

    while (size >= 1024 && unit_idx < units.length - 1) {
        size = size / 1024;
        unit_idx = unit_idx + 1;
    }

    if (unit_idx == 0) {
        // Bytes - no decimal
        return bytes + " B";
    }

    let formatted = format_float(size, precision);
    return formatted + " " + units[unit_idx];
}

// Format duration in seconds as human-readable
// Parameters:
//   seconds: f64 - Duration in seconds
// Returns: string - Formatted duration
export fn duration(seconds): string {
    if (seconds < 0) {
        return "-" + duration(-seconds);
    }

    if (seconds < 1) {
        let ms = seconds * 1000;
        return format_float(ms, 1) + "ms";
    }

    if (seconds < 60) {
        return format_float(seconds, 1) + "s";
    }

    let total_secs: i64 = seconds;
    let mins = divi(total_secs, 60);
    let secs = total_secs % 60;

    if (mins < 60) {
        return mins + "m " + secs + "s";
    }

    let hours = divi(mins, 60);
    mins = mins % 60;

    if (hours < 24) {
        return hours + "h " + mins + "m";
    }

    let days = divi(hours, 24);
    hours = hours % 24;

    return days + "d " + hours + "h";
}

// Format number as ordinal (1st, 2nd, 3rd, etc.)
// Parameters:
//   n: i32 - Number
// Returns: string - Ordinal string
export fn ordinal(n): string {
    let num: i64 = n;
    if (num < 0) {
        num = -num;
    }

    let suffix = "th";
    let last_digit = num % 10;
    let last_two = num % 100;

    if (last_two >= 11 && last_two <= 13) {
        suffix = "th";
    } else if (last_digit == 1) {
        suffix = "st";
    } else if (last_digit == 2) {
        suffix = "nd";
    } else if (last_digit == 3) {
        suffix = "rd";
    }

    return n + suffix;
}

// Format percentage
// Parameters:
//   value: f64 - Value (0.0 to 1.0)
//   precision: i32 - Decimal places (default: 1)
// Returns: string - Percentage string
export fn percent(value, precision?: 1): string {
    let pct = value * 100;
    return format_float(pct, precision) + "%";
}
