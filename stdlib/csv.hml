// @stdlib/csv - CSV parsing and generation
//
// Provides functions for reading and writing CSV (Comma-Separated Values) data.
//
// Usage:
//   import { parse, stringify, parse_row, stringify_row } from "@stdlib/csv";
//   let data = parse(csv_text);

// ============================================================================
// CSV Parsing
// ============================================================================

// Parse a CSV string into an array of rows (each row is an array of strings)
// Parameters:
//   text: string - CSV text to parse
//   options: object - Optional { delimiter?: ",", quote?: "\"", skip_header?: false }
// Returns: array<array<string>> - Array of rows
export fn parse(text, options?: null): array {
    if (typeof(text) != "string") {
        throw "parse() requires string argument";
    }

    // Get options
    let delimiter = ",";
    let quote = "\"";
    let skip_header = false;

    if (options != null && typeof(options) == "object") {
        let opt_delim = options["delimiter"];
        let opt_quote = options["quote"];
        let opt_skip = options["skip_header"];

        if (opt_delim != null && typeof(opt_delim) == "string") {
            delimiter = opt_delim;
        }
        if (opt_quote != null && typeof(opt_quote) == "string") {
            quote = opt_quote;
        }
        if (opt_skip != null && typeof(opt_skip) == "bool") {
            skip_header = opt_skip;
        }
    }

    let rows: array = [];
    let current_row: array = [];
    let current_field = "";
    let in_quotes = false;
    let i = 0;

    while (i < text.length) {
        let c = text.substr(i, 1);

        if (in_quotes) {
            // Inside quoted field
            if (c == quote) {
                // Check for escaped quote (double quote)
                if (i + 1 < text.length && text.substr(i + 1, 1) == quote) {
                    current_field = current_field + quote;
                    i = i + 2;
                    continue;
                }
                // End of quoted field
                in_quotes = false;
            } else {
                current_field = current_field + c;
            }
        } else {
            // Outside quoted field
            if (c == quote) {
                in_quotes = true;
            } else if (c == delimiter) {
                // End of field
                current_row.push(current_field);
                current_field = "";
            } else if (c == "\n") {
                // End of row
                current_row.push(current_field);
                current_field = "";
                rows.push(current_row);
                current_row = [];
            } else if (c == "\r") {
                // Handle CRLF
                if (i + 1 < text.length && text.substr(i + 1, 1) == "\n") {
                    i = i + 1;  // Skip the \n, will be handled next iteration
                }
                // End of row
                current_row.push(current_field);
                current_field = "";
                rows.push(current_row);
                current_row = [];
            } else {
                current_field = current_field + c;
            }
        }

        i = i + 1;
    }

    // Handle last field/row
    if (current_field.length > 0 || current_row.length > 0) {
        current_row.push(current_field);
        rows.push(current_row);
    }

    // Skip header if requested
    if (skip_header && rows.length > 0) {
        rows = rows.slice(1, rows.length);
    }

    return rows;
}

// Parse CSV with headers - returns array of objects
// Parameters:
//   text: string - CSV text to parse
//   options: object - Optional { delimiter?: ",", quote?: "\"" }
// Returns: array<object> - Array of objects with header keys
export fn parse_objects(text, options?: null): array {
    if (typeof(text) != "string") {
        throw "parse_objects() requires string argument";
    }

    let rows = parse(text, options);

    if (rows.length == 0) {
        return [];
    }

    let headers = rows[0];
    let result: array = [];

    let i = 1;
    while (i < rows.length) {
        let row = rows[i];
        let obj = {};

        let j = 0;
        while (j < headers.length && j < row.length) {
            obj[headers[j]] = row[j];
            j = j + 1;
        }

        result.push(obj);
        i = i + 1;
    }

    return result;
}

// Parse a single CSV row
// Parameters:
//   line: string - Single CSV line
//   options: object - Optional { delimiter?: ",", quote?: "\"" }
// Returns: array<string> - Array of field values
export fn parse_row(line, options?: null): array {
    if (typeof(line) != "string") {
        throw "parse_row() requires string argument";
    }

    let rows = parse(line, options);
    if (rows.length > 0) {
        return rows[0];
    }
    return [];
}

// ============================================================================
// CSV Generation
// ============================================================================

// Convert an array of rows to CSV string
// Parameters:
//   rows: array<array<string>> - Array of rows
//   options: object - Optional { delimiter?: ",", quote?: "\"", line_ending?: "\n" }
// Returns: string - CSV text
export fn stringify(rows, options?: null): string {
    if (typeof(rows) != "array") {
        throw "stringify() requires array argument";
    }

    // Get options
    let delimiter = ",";
    let quote = "\"";
    let line_ending = "\n";

    if (options != null && typeof(options) == "object") {
        let opt_delim = options["delimiter"];
        let opt_quote = options["quote"];
        let opt_ending = options["line_ending"];

        if (opt_delim != null && typeof(opt_delim) == "string") {
            delimiter = opt_delim;
        }
        if (opt_quote != null && typeof(opt_quote) == "string") {
            quote = opt_quote;
        }
        if (opt_ending != null && typeof(opt_ending) == "string") {
            line_ending = opt_ending;
        }
    }

    let result = "";
    let i = 0;

    while (i < rows.length) {
        let row = rows[i];
        if (typeof(row) != "array") {
            throw "stringify() rows must contain arrays";
        }

        result = result + stringify_row(row, options);

        if (i < rows.length - 1) {
            result = result + line_ending;
        }

        i = i + 1;
    }

    return result;
}

// Convert an array of objects to CSV string
// Parameters:
//   objects: array<object> - Array of objects
//   headers: array<string> - Column headers (also used as object keys)
//   options: object - Optional { delimiter?: ",", quote?: "\"", line_ending?: "\n" }
// Returns: string - CSV text
export fn stringify_objects(objects, headers, options?: null): string {
    if (typeof(objects) != "array") {
        throw "stringify_objects() requires array argument";
    }
    if (typeof(headers) != "array") {
        throw "stringify_objects() headers must be array";
    }

    // Get options
    let line_ending = "\n";
    if (options != null && typeof(options) == "object") {
        let opt_ending = options["line_ending"];
        if (opt_ending != null && typeof(opt_ending) == "string") {
            line_ending = opt_ending;
        }
    }

    // Build rows array
    let rows: array = [];
    rows.push(headers);

    let i = 0;
    while (i < objects.length) {
        let obj = objects[i];
        let row: array = [];

        let j = 0;
        while (j < headers.length) {
            let key = headers[j];
            let value = obj[key];
            if (value == null) {
                row.push("");
            } else {
                row.push("" + value);
            }
            j = j + 1;
        }

        rows.push(row);
        i = i + 1;
    }

    return stringify(rows, options);
}

// Convert a single row to CSV line
// Parameters:
//   row: array<string> - Array of field values
//   options: object - Optional { delimiter?: ",", quote?: "\"" }
// Returns: string - CSV line
export fn stringify_row(row, options?: null): string {
    if (typeof(row) != "array") {
        throw "stringify_row() requires array argument";
    }

    // Get options
    let delimiter = ",";
    let quote = "\"";

    if (options != null && typeof(options) == "object") {
        let opt_delim = options["delimiter"];
        let opt_quote = options["quote"];

        if (opt_delim != null && typeof(opt_delim) == "string") {
            delimiter = opt_delim;
        }
        if (opt_quote != null && typeof(opt_quote) == "string") {
            quote = opt_quote;
        }
    }

    let result = "";
    let i = 0;

    while (i < row.length) {
        let field = "" + row[i];

        // Check if field needs quoting
        let needs_quote = false;
        if (field.contains(delimiter) || field.contains(quote) ||
            field.contains("\n") || field.contains("\r")) {
            needs_quote = true;
        }

        if (needs_quote) {
            // Escape quotes by doubling them
            let escaped = field.replace_all(quote, quote + quote);
            result = result + quote + escaped + quote;
        } else {
            result = result + field;
        }

        if (i < row.length - 1) {
            result = result + delimiter;
        }

        i = i + 1;
    }

    return result;
}

// ============================================================================
// Utility Functions
// ============================================================================

// Get column from CSV data
// Parameters:
//   rows: array<array<string>> - CSV data
//   index: i32 - Column index
// Returns: array<string> - Column values
export fn get_column(rows, index): array {
    if (typeof(rows) != "array") {
        throw "get_column() requires array argument";
    }

    let result: array = [];
    let i = 0;

    while (i < rows.length) {
        let row = rows[i];
        if (typeof(row) == "array" && index < row.length) {
            result.push(row[index]);
        } else {
            result.push("");
        }
        i = i + 1;
    }

    return result;
}

// Get row count
// Parameters:
//   rows: array<array<string>> - CSV data
// Returns: i32 - Number of rows
export fn row_count(rows): i32 {
    if (typeof(rows) != "array") {
        throw "row_count() requires array argument";
    }
    return rows.length;
}

// Get column count (from first row)
// Parameters:
//   rows: array<array<string>> - CSV data
// Returns: i32 - Number of columns
export fn column_count(rows): i32 {
    if (typeof(rows) != "array") {
        throw "column_count() requires array argument";
    }
    if (rows.length == 0) {
        return 0;
    }
    let first = rows[0];
    if (typeof(first) != "array") {
        return 0;
    }
    return first.length;
}
